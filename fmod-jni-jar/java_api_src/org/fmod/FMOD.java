package org.fmod;

import java.io.File;

/**
 * Top-level class to handle JNI initialization and FMOD result error handling.
 *
 * The FMOD C/C++ API returns an FMOD result from each call, and uses out parameters to return
 * objects and information. Java really doesn't work that way (see: no pointers).
 *
 * This Java api is intended to be an idiomatic Java translation of the C++ FMOD API.
 *
 * Because FMOD results can communicate non-fatal failures, it's also not appropriate to throw errors.
 * Instead, this api simply allows you to retrieve the last result directly. You can do what you want.
 *
 *
 *
 * TODO: The jni code is generated by SWIG and is honestly pretty ugly. A better solution might be to hand-roll the interface, but, I don't have the time/inclination to try it.
 *
 * TODO: the "constants" file is horribly named, located, and formatted. find a better solution. Oh also.. it makes static jni calls. SO GROSS.
 *
 * Author: Nate
 * Date: 5/1/2015
 */
public class FMOD {


	/**
	 * Load the fmod runtime libraries. This must be called before any apis can be used.
	 *
	 * This function assumes the native libs are located in the working directory working directory.
	 * TODO: determine load order for native dependencies so we can load them correctly instead of requiring them on the PATH.
	 *
	 * This function has no other side effects.
	 * Please call only once?
	 *
	 *
	 * @return true if the library was loaded, false otherwise.
	 */
	public static boolean loadNatives() {
		//This logic was cribbed from:
		//com.badlogic.gdx.jnigen/JniGenSharedLibraryLoader
		//https://github.com/libgdx/libgdx/blob/26f1c3fbc5a96ffd9e63d31c2b07f8d5dac9c95d/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/JniGenSharedLibraryLoader.java
		//Thanks!
		String folderName = "";
		String sharedLibName = "fmodJNI";

		boolean isWindows = java.lang.System.getProperty("os.name").contains("Windows");
		boolean isLinux = java.lang.System.getProperty("os.name").contains("Linux");
		boolean isMac = java.lang.System.getProperty("os.name").contains("Mac");
		boolean isAndroid = false;
		boolean is64Bit = java.lang.System.getProperty("os.arch").equals("amd64") || java.lang.System.getProperty("os.arch").equals("x86_64");
		String vm = java.lang.System.getProperty("java.vm.name");
		if (vm != null && vm.contains("Dalvik")) {
			isAndroid = true;
			isWindows = false;
			isLinux = false;
			isMac = false;
			is64Bit = false;
		}

		boolean loaded = false;
		if (isWindows) {
			if (!is64Bit)
				loaded = loadLibrary(folderName, sharedLibName + ".dll");
			else
				loaded = loadLibrary(folderName, sharedLibName + "64.dll");
		}
		if (isLinux) {
			if (!is64Bit)
				loaded = loadLibrary(folderName, "lib" + sharedLibName + ".so");
			else
				loaded = loadLibrary(folderName, "lib" + sharedLibName + "64.so");
		}
		if (isMac) {
			if (!is64Bit)
				loaded = loadLibrary(folderName, "lib" + sharedLibName + ".dylib");
			else
				loaded = loadLibrary(folderName, "lib" + sharedLibName + "64.dylib");
		}
		if (isAndroid) {
			loaded = loadAndroidLibrary(folderName, sharedLibName);
		}
		return loaded;
	}

	private static boolean loadAndroidLibrary(String folderName, String libName) {
		try {
			java.lang.System.loadLibrary(folderName + libName);
			return true;
		} catch (UnsatisfiedLinkError linkError) {
			java.lang.System.out.println("failed to load " + libName);
			linkError.printStackTrace();
		}
		return false;
	}

	private static boolean loadLibrary(String folderName, String libName) {
		try {
			File workingFolder = new File(".");
//			File libPath = new File(workingFolder, folderName);
			File target = new File(workingFolder, folderName + libName);
//			java.lang.System.setProperty("java.library.path", libPath.getAbsolutePath());
			java.lang.System.load(target.getAbsolutePath());
			return true;
		} catch (UnsatisfiedLinkError linkError) {
			java.lang.System.out.println("failed to load " + libName);
			linkError.printStackTrace();
		}
		return false;
	}


	//TODO: add global system functions:
	//inline FMOD_RESULT Memory_Initialize    (void *poolmem, int poollen, FMOD_MEMORY_ALLOC_CALLBACK useralloc, FMOD_MEMORY_REALLOC_CALLBACK userrealloc, FMOD_MEMORY_FREE_CALLBACK userfree, FMOD_MEMORY_TYPE memtypeflags = FMOD_MEMORY_ALL) { return FMOD_Memory_Initialize(poolmem, poollen, useralloc, userrealloc, userfree, memtypeflags); }
	//inline FMOD_RESULT Memory_GetStats      (int *currentalloced, int *maxalloced, bool blocking = true) { return FMOD_Memory_GetStats(currentalloced, maxalloced, blocking); }
	//inline FMOD_RESULT Debug_Initialize     (FMOD_DEBUG_FLAGS flags, FMOD_DEBUG_MODE mode = FMOD_DEBUG_MODE_TTY, FMOD_DEBUG_CALLBACK callback = 0, const char *filename = 0) { return FMOD_Debug_Initialize(flags, mode, callback, filename); }
	//inline FMOD_RESULT File_SetDiskBusy     (int busy) { return FMOD_File_SetDiskBusy(busy); }
	//inline FMOD_RESULT File_GetDiskBusy     (int *busy) { return FMOD_File_GetDiskBusy(busy); }

	//...
}
