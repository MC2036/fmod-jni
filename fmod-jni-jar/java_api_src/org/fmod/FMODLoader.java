package org.fmod;

import java.io.*;
import java.util.zip.CRC32;

/**
 * Top-level class to handle JNI initialization
 * <p>
 * <p>
 * TODO: The jni code is generated by SWIG and is honestly pretty ugly. A better solution might be to hand-roll the interface, but, I don't have the time/inclination to try it.
 * <p>
 * TODO: the "constants" file is horribly named, located, and formatted. find a better solution. Oh also.. it makes static jni calls. SO GROSS.
 * <p>
 * Author: Nate
 * Date: 5/1/2015
 */
public class FMODLoader {

	/**
	 * retrieve the error message
	 */
	public static String error;

	/**
	 * Load the fmod runtime libraries. This must be called before any apis can be used.
	 * <p>
	 * This function assumes the native libs are located in the working directory working directory.
	 * TODO: determine load order for native dependencies so we can load them correctly instead of requiring them on the PATH.
	 * <p>
	 * This function has no other side effects.
	 * Please call only once?
	 *
	 * @return true if the library was loaded, false otherwise.
	 */
	public static boolean loadNatives() {
		//This logic was cribbed from:
		//com.badlogic.gdx.jnigen/JniGenSharedLibraryLoader
		//https://github.com/libgdx/libgdx/blob/26f1c3fbc5a96ffd9e63d31c2b07f8d5dac9c95d/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/JniGenSharedLibraryLoader.java
		//Thanks!
		String folder = "/fmod_runtimes/";

		boolean isWindows = java.lang.System.getProperty("os.name").contains("Windows");
		boolean isLinux = java.lang.System.getProperty("os.name").contains("Linux");
		boolean isMac = java.lang.System.getProperty("os.name").contains("Mac");
		boolean isAndroid = false;
		boolean is64Bit = java.lang.System.getProperty("os.arch").equals("amd64") || java.lang.System.getProperty("os.arch").equals("x86_64");
		String vm = java.lang.System.getProperty("java.vm.name");
		if (vm != null && vm.contains("Dalvik")) {
			isAndroid = true;
			isWindows = false;
			isLinux = false;
			isMac = false;
			is64Bit = false;
		}

		//any other stuff here?

		//first, the fmod low level dll
		if (!loadNativeLibraryFromJar(folder, "fmodL", isWindows, isLinux, isMac, isAndroid, is64Bit)) return false;
		//then the fmod studio dll
		if (!loadNativeLibraryFromJar(folder, "fmodstudioL", isWindows, isLinux, isMac, isAndroid, is64Bit))
			return false;
		//finally, our JNI glue DLL
		return loadNativeLibraryFromJar(folder, "fmodJNI", isWindows, isLinux, isMac, isAndroid, is64Bit);
	}

	private static boolean loadNativeLibraryFromJar(String folderName, String sharedLibName, boolean isWindows, boolean isLinux, boolean isMac, boolean isAndroid, boolean is64Bit) {
		boolean loaded = false;
		if (isWindows) {
			if (!is64Bit)
				loaded = loadLibrary(folderName + sharedLibName + ".dll");
			else
				loaded = loadLibrary(folderName + sharedLibName + "64.dll");
		}
		if (isLinux) {
			if (!is64Bit)
				loaded = loadLibrary(folderName + "lib" + sharedLibName + ".so");
			else
				loaded = loadLibrary(folderName + "lib" + sharedLibName + "64.so");
		}
		if (isMac) {
			if (!is64Bit)
				loaded = loadLibrary(folderName + "lib" + sharedLibName + ".dylib");
			else
				loaded = loadLibrary(folderName + "lib" + sharedLibName + "64.dylib");
		}
		if (isAndroid) {
			loaded = loadAndroidLibrary(folderName, sharedLibName);
		}
		return loaded;
	}

	private static boolean loadAndroidLibrary(String folderName, String libName) {
		try {
			java.lang.System.loadLibrary(folderName + libName);
			return true;
		} catch (UnsatisfiedLinkError linkError) {
			failWithError(libName, linkError);
		}
		return false;
	}

	private static boolean loadLibrary(String sharedLibName) {
		if (sharedLibName == null) return false;

		try {
			String path = extractLibrary(sharedLibName);
			if (path != null) {
				System.load(path);
				return true;
			}
		} catch (Throwable t) {
			failWithError(sharedLibName, t);
		}
		return false;
	}

	private static void failWithError(String sharedLibName, Throwable t) {
		StringWriter writer = new StringWriter(256);
		t.printStackTrace(new PrintWriter(writer));
		String errMsg = writer.toString().trim();
		error = "failed to load " + sharedLibName + t.toString() + ": " + errMsg;
		System.out.println(error);
	}

	/**
	 * Returns a CRC of the remaining bytes in the stream.
	 */
	public static String crc(InputStream input) {
		if (input == null) return "" + System.nanoTime(); // fallback
		CRC32 crc = new CRC32();
		byte[] buffer = new byte[4096];
		try {
			while (true) {
				int length = input.read(buffer);
				if (length == -1) break;
				crc.update(buffer, 0, length);
			}
		} catch (Exception ex) {
			try {
				input.close();
			} catch (Exception ignored) {
			}
		}
		return Long.toString(crc.getValue());
	}

	private static String extractLibrary(String sharedLibName) {
		String srcCrc = crc(FMODLoader.class.getResourceAsStream("/" + sharedLibName));
		File nativesDir = new File(System.getProperty("java.io.tmpdir") + "/jnigen/" + srcCrc);
		File nativeFile = new File(nativesDir, sharedLibName);

		String extractedCrc = null;
		if (nativeFile.exists()) {
			try {
				extractedCrc = crc(new FileInputStream(nativeFile));
			} catch (FileNotFoundException ignored) {
			}
		}

		if (extractedCrc == null || !extractedCrc.equals(srcCrc)) {
			try {
				// Extract native from classpath to temp dir.
				InputStream input = null;
				input = FMODLoader.class.getResourceAsStream(sharedLibName);
				if (input == null) return null;
				nativeFile.getParentFile().mkdirs();
				FileOutputStream output = new FileOutputStream(nativeFile);
				byte[] buffer = new byte[4096];
				while (true) {
					int length = input.read(buffer);
					if (length == -1) break;
					output.write(buffer, 0, length);
				}
				input.close();
				output.close();
			} catch (IOException ex) {
				ex.printStackTrace();
				throw new RuntimeException(ex);
			}
		}
		return nativeFile.exists() ? nativeFile.getAbsolutePath() : null;
	}


	//TODO: add global system functions:
	//inline FMOD_RESULT Memory_Initialize    (void *poolmem, int poollen, FMOD_MEMORY_ALLOC_CALLBACK useralloc, FMOD_MEMORY_REALLOC_CALLBACK userrealloc, FMOD_MEMORY_FREE_CALLBACK userfree, FMOD_MEMORY_TYPE memtypeflags = FMOD_MEMORY_ALL) { return FMOD_Memory_Initialize(poolmem, poollen, useralloc, userrealloc, userfree, memtypeflags); }
	//inline FMOD_RESULT Memory_GetStats      (int *currentalloced, int *maxalloced, bool blocking = true) { return FMOD_Memory_GetStats(currentalloced, maxalloced, blocking); }
	//inline FMOD_RESULT Debug_Initialize     (FMOD_DEBUG_FLAGS flags, FMOD_DEBUG_MODE mode = FMOD_DEBUG_MODE_TTY, FMOD_DEBUG_CALLBACK callback = 0, const char *filename = 0) { return FMOD_Debug_Initialize(flags, mode, callback, filename); }
	//inline FMOD_RESULT File_SetDiskBusy     (int busy) { return FMOD_File_SetDiskBusy(busy); }
	//inline FMOD_RESULT File_GetDiskBusy     (int *busy) { return FMOD_File_GetDiskBusy(busy); }

	//...
}
